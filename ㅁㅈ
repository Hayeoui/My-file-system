

#include
<stdio.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
union file_contents {
        char dc[24][7];
        char fc[128];
        short ind[102];
};
typedef struct data_info {
        union file_contents con;
        struct data_info *next;
        struct data_info *down;
        struct data_info *link;
        int parent;
        int d_num;
} data; // 포인터 byte는 따로 생각한다.
struct file_time {
        int year;
        int month;
        int day;
        int hour;
        int minute;
        int seconds  ;
}; 
typedef struct inode_info { 
        char *file_type;  
        struct file_time f_t;  
        int file_size;
        int db;
        int sib;
        int dib;
} inode;
typedef struct super_info {
        unsigned char inode_use[64]; // 8
* 64 = 512
        unsigned char datablock_use[128];
// 8 * 128 = 1024
} super;
data *dblock[1024] = {NULL};
int update_mymkfs(super *, inode *, inode **);
int func_mymkfs(super *, inode *, struct tm *, inode **); // 0) mymkfs
void func_mystate(super *); // 16 ) mystate
void func_mymkdir(super *, inode *, char [], struct tm *, int, inode *); // 9)
mymkdir
int space_inode(super *);
int space_data(super *);
void bit_inode(super *, int);
void bit_data(super *, int);
int name_find(inode *, char [], inode *);
int main(void)
{
        struct tm *t;
        time_t now;
        now = time(NULL);
        t = localtime(&now);
        // 파일 생성 날짜

        unsigned short boot_block;
        super superblock = {{0}, {0}};

        inode inode_list[512] = {0};

        int c = 0;
        char words[100];
        int i, j, co_num, space = 0;
        int find = 0;
        char compare[20]; 

        char *command[18] =
{"mymkfs", "myls", "mycat",
"myshowfile", "mypwd", "mycd", "mycp",
"mycpto", "mycpfrom", "mymkdir",
"myrmdir", "myrm", "mymv", "mytouch",
"myshowinode", "myshowblock", "mystate",
"mytree"};
        
        char *file_name =
"myfs";   // mymkfs파일
        int mymkfs_check = 0;

        inode *now_d =
&inode_list[0];
        int now_d_num;
                   // 현재 디렉터리 가리키는 포인터.


        while(1)
        {
               if(access(file_name,
F_OK)!=0)
               {
                       printf("error
: no myfs\n");
                       mymkfs_check =
1;
               }
               else
               {
                       if(mymkfs_check ==
0)
                              now_d_num =
update_mymkfs(&superblock, inode_list, &now_d); // 있으면 불러오기.
                       mymkfs_check =
1;
               }

               co_num = 0;
                space
= 0;
               for(i=0; words[i-1]!='\n';
++i)
               {
                       c =
getchar();
                       words[i] = c;
               }
               words[i-1] = '\0';


               for(i=0; words[i]!='\0';
++i)
                       if(words[i] == '
')
                              space++;

               if(space==0)
               {
                       for(i=0;
words[i]!='\0'; ++i)
                              compare[i] =
words[i];
                       compare[i] =
'\0';
               }
               else
               {
                       for(i=0;
words[i]!=' '; ++i)
                              compare[i] =
words[i];
                       compare[i] =
'\0';
               }

               if(space==0)
                       words[0] =
'\0';
               else
               {
                       for(j=i+1;
words[j]!='\0'; ++j)
                              words[j-(i+1)]
= words[j];
                       words[j-(i+1)] =
'\0';
               }

               for(co_num=0; co_num<18;
co_num++)
               {
                       if(strcmp(compare,
command[co_num])==0)      
                       break;
               }


               // 명령어 함수 호출 부분 시작
               

               if(co_num == 0)
               {
                       if(access(file_name,
F_OK) == 0)
                              printf("error
: myfs exists\n");
                       else
                              now_d_num =
func_mymkfs(&superblock, inode_list, t, &now_d); // mymkfs실행 후 myfs가 없을 때 만듬.
               }
               else
               {
                       if(access(file_name,
F_OK) == 0)
                       {
                              if(co_num ==
1)
                              {
                              }
                              else
if(co_num == 2)
                              {
                              }
                              else
if(co_num == 3)
                              {
                              }
                              else if(co_num
== 4)
                              {
                              }
                              else
if(co_num == 5)
                              {
                              }
                              else
if(co_num == 6)
                              {
                              }
                              else
if(co_num == 7)
                              {
                              }
                              else
if(co_num == 8)
                              {
                              }
                              else
if(co_num == 9)
                              {
                                      find
= name_find(inode_list, words, now_d);
                                      if(find == 0)
                                             func_mymkdir(&superblock,
inode_list, words, t, now_d_num, now_d);
                                      else
if(find == 1)
                                             printf("mymkdir
: '%s' 디렉토리를 만들 수 없습니다: Directory exists\n",
words);
                                      else
                                             printf("mymkdir
: '%s' 디렉토리를 만들 수 없습니다: File exists\n",
words);
                              }
                              else
if(co_num == 10)
                              {
                              }
                              else
if(co_num == 11)
                              {
                              }
                              else
if(co_num == 12)
                              {
                              }
                              else
if(co_num == 13)
                              {
                              }
                              else
if(co_num == 14)
                              {
                              }
                              else
if(co_num == 15)
                              {
                              }
                              else if(co_num
== 16)
                              {
                                      func_mystate(&superblock);
                              }
                              else
if(co_num == 17)
                              {
                              }
                              else //
co_num == 18(cygwin 명령어 실행)
                              {
                                      if(strcmp(compare,
"byebye")==0)
                                             exit(0);
                                      else
                                      {
                                             for(i=0;
compare[i]!='\0'; ++i)
                                                     ;
                                             if(words[0]
== '\n')
                                                     system(compare);
                                             else
                                             {
                                                     compare[i]
= ' ';
                                                     for(j=i;
words[i]!='\0'; ++j)
                                                                    compare[j+1]
= words[j-i];
                                                     compare[j+1]
= '\0';
                                                     system(compare);
                                             }
                                             
                                      }
                              }
                       }
                       else
                              printf("error
: no myfs\n");
               }
        }

               
               return 0;
}
int update_mymkfs(super *sp, inode *ip, inode **now_dp)
{
        // 이미 myfs가
있어서 myfs에 들어있는 내용 불러오기.
        // 불러온 후 파일시스템 실행해도 기본 위치는 / 디렉토리.
        printf("updating.....\n");

        *now_dp = &ip[0];
        
        return 0;
}
int func_mymkfs(super *sp, inode *ip, struct tm *t, inode **now_dp)
{
        // 파일시스템 실행 후 myfs가 없을때 생성.
        system("touch
myfs");
        
        time_t now;
        now = time(NULL);
        t = localtime(&now);

        ip[0].file_type =
"directory";
        ip[0].f_t.year =
1900+t->tm_year;
        ip[0].f_t.month =
1+t->tm_mon;
        ip[0].f_t.day =
t->tm_mday;
        ip[0].f_t.hour =
t->tm_hour;
        ip[0].f_t.minute =
t->tm_min;
        ip[0].f_t.seconds =
t->tm_sec;
        ip[0].file_size = 0;
        ip[0].db = 0;  // 0번 데이터 블록
        ip[0].sib = -1;  
        ip[0].dib = -1;  // -1 = 없음.
        dblock[0] = (data
*)malloc(sizeof(data));
        dblock[0]->con.dc[0][0] =
'\0';
        dblock[0]->next = NULL;
        dblock[0]->down = NULL;
        dblock[0]->link = NULL;
        dblock[0]->d_num = 0;
        dblock[0]->parent = -1; // -1 =
없음.
        
        sp -> inode_use[0] = 1 <<
0;
        sp -> datablock_use[0] = 1
<< 0;

        *now_dp = &ip[0];

        return 0;
}
void func_mymkdir(super *sp, inode *ip, char words[], struct tm *t, int
now_d_num, inode *now_d)
{

        time_t now;
        now = time(NULL);
        t = localtime(&now);

        int in, dn, i, s_dn, n_dn;
        int j, k, a;
        data *tmp;
        
        in = space_inode(sp);
        bit_inode(sp, in);

        dn = space_data(sp);
        bit_data(sp, dn);

        ip[in].file_type =
"directory";
        ip[in].f_t.year =
1900+t->tm_year;
        ip[in].f_t.month =
1+t->tm_mon;
        ip[in].f_t.day =
t->tm_mday;
        ip[in].f_t.hour =
t->tm_hour;
        ip[in].f_t.minute =
t->tm_min;
        ip[in].f_t.seconds =
t->tm_sec;
        ip[in].db = dn;
        ip[in].sib = -1;
        ip[in].dib = -1;
        dblock[dn] = (data
*)malloc(sizeof(data));
        dblock[dn]->con.dc[0][0] =
'\0';
        dblock[dn]->next = NULL;
        dblock[dn]->down = NULL;
        dblock[dn]->link = NULL;
        dblock[dn]->parent =
now_d_num;
        dblock[dn]->d_num = dn;

        // 부모, 형제
디렉터리와 연결
        if(dblock[now_d->db]->con.dc[0][0]=='\0')
               dblock[now_d->db]->down
= dblock[dn];
        else
        {
               tmp =
dblock[now_d->db];
               while(tmp->next !=
'\0')
               {
                       tmp = tmp->next;
               }
               tmp->next =
dblock[dn];
        }

        // 현재 디렉토리에 아이노드와 디렉토리의 이름 적기.
        for(i=0; i<24; ++i)
               if(dblock[now_d->db]->con.dc[i][0]=='\0')
                       break;
        if(i!=24)
        {
               dblock[now_d->db]->con.dc[i][0]
= in / 100 + 48;
               dblock[now_d->db]->con.dc[i][1]
= (in % 100) / 10 + 48;
               dblock[now_d->db]->con.dc[i][2]
= (in % 10) + 48;

               for(j=0; words[j]!='\0';
++j)
                       dblock[now_d->db]->con.dc[i][j+3]
= words[j];
               dblock[now_d->db]->con.dc[i][j+3]
= '\0';
               dblock[now_d->db]->con.dc[i+1][0]
= '\0';

        }
        else
        {
               if(now_d->sib ==
-1)
               {
                       s_dn =
space_data(sp);
                       bit_data(sp,
s_dn);

                       dblock[s_dn] =
(data *)malloc(sizeof(data));
                       now_d->sib =
s_dn;
                       dblock[s_dn]->con.ind[0]
= 0;
                       dblock[s_dn]->next
= NULL;
                       dblock[s_dn]->down
= NULL;
                       dblock[s_dn]->link
= NULL;
                       dblock[s_dn]->parent
= -1;
                       dblock[s_dn]->d_num
= s_dn;

                       n_dn =
space_data(sp);
                       bit_data(sp,
n_dn);

                       dblock[n_dn] =
(data *)malloc(sizeof(data));
                       dblock[n_dn]->next
= NULL;
                       dblock[n_dn]->down
= NULL;
                       dblock[n_dn]->link
= NULL;
                       dblock[n_dn]->parent
= -1;
                       dblock[n_dn]->d_num
= n_dn;

                       dblock[n_dn]->con.dc[0][0]
= in / 100 + 48;
                       dblock[n_dn]->con.dc[0][1]
= (in % 100) / 10 + 48;
                       dblock[n_dn]->con.dc[0][2]
= in % 10 + 48;

                       for(i=0; words[i]
!='\0'; ++i)
                              dblock[n_dn]->con.dc[0][i+3]
= words[i];
                       dblock[n_dn]->con.dc[0][i+3]
= '\0';
                       dblock[n_dn]->con.dc[1][0]
= '\0';

                       dblock[s_dn]->con.ind[0]
= n_dn;
                       dblock[s_dn]->con.ind[1]
= 0;

                       tmp =
dblock[now_d->db];
                       while(tmp->link
!= NULL)
                       {
                              tmp = tmp->link;
                       }
                       tmp->link =
dblock[n_dn];

               }
               else
               {
                       for(i=0; i<102;
++i)
                              if(dblock[now_d->sib]->con.ind[i]==0)
                                      break;

                       // i 값 : single indirect 에서 0인 부분
                       a =
dblock[now_d->sib]->con.ind[i-1];
                       for(j=0; j<24;
++j)
                              if(dblock[a]->con.dc[j][0]
== '\0')
                                      break;


                       if(j!=24)
                       {
                              dblock[a]->con.dc[j][0]
= in / 100 + 48;
                              dblock[a]->con.dc[j][1]
= (in % 100) / 10 + 48;
                              dblock[a]->con.dc[j][2]
= in % 10 + 48;

                              for(k=0;
words[k]!='\0'; ++k)
                                      dblock[a]->con.dc[j][k+3]
= words[k];
                              dblock[a]->con.dc[j][k+3]
= '\0';
                              dblock[a]->con.dc[j+1][0]
= '\0';
                       }
                       else
                       {
                              n_dn =
space_data(sp);
                              bit_data(sp,
n_dn);

                              dblock[n_dn]
= (data *)malloc(sizeof(data));
                              dblock[n_dn]->next
= NULL;
                              dblock[n_dn]->down
= NULL;
                              dblock[n_dn]->link
= NULL;
                              dblock[n_dn]->parent
= -1;
                              dblock[n_dn]->d_num
= n_dn;

                              dblock[n_dn]->con.dc[0][0]
= in / 100 + 48;
                              dblock[n_dn]->con.dc[0][1]
= (in % 100) / 10 + 48;
                              dblock[n_dn]->con.dc[0][2]
= in % 10 + 48;

                              for(j=0;
words[j]!='\0'; ++j)
                                      dblock[n_dn]->con.dc[0][j+3]
= words[j];
                              dblock[n_dn]->con.dc[0][j+3]
= '\0';
                              dblock[n_dn]->con.dc[1][0]
= '\0';

                              dblock[now_d->sib]->con.ind[i]
= n_dn;
                              dblock[now_d->sib]->con.ind[i+1]
= 0;

                              tmp =
dblock[now_d->db];
                              while(tmp->link
!= NULL)
                              {
                                      tmp
= tmp->link;
                              }
                              tmp->link
= dblock[n_dn];
                       }
                       
               }
        }

}
void func_mystate(super *sp)
{
        int i, j, quotient;
        int bit[8];
        int count_i = 0, count_d =
0;
        for(i=0; i<64; ++i)
        {
               quotient = sp ->
inode_use[i];
               for(j=0; j<8; ++j)
               {
                       bit[j] = quotient %
2;
                       quotient = quotient
/ 2;
               }

               for(j=0; j<8; ++j)
                       if(bit[j] ==
0)
                              ++count_i;
        }

        for(i=0; i<128; ++i)
        {
               quotient = sp ->
datablock_use[i];
               for(j=0; j<8; ++j)
               {
                       bit[j] = quotient %
2;
                       quotient = quotient
/ 2;
               }

               for(j=0; j<8; ++j)
                       if(bit[j] ==
0)
                              ++count_d;
        }

        printf("free inode :
%d\n", count_i);
        printf("free data block :
%d\n", count_d);
}
int space_inode(super *sp)
{
        int i, j, quotient, stop=0;
        int bit[8];

        for(i=0; i<64; ++i)
        {
               quotient =
sp->inode_use[i];
               for(j=0; j<8; ++j)
               {
                       bit[j] = quotient %
2;
                       quotient = quotient
/ 2;
               }
               for(j=0; j<8; ++j)
                       if(bit[j]==0)
                       {
                              stop =
1;
                              break;
                       }
               if(stop == 1)
                       break;
        }

        j = 8 * i + j;

        return j;
}
int space_data(super *sp)
{
        int i, j, quotient, stop =
0;
        int bit[8];

        for(i=0; i<512; ++i)
        {
               quotient =
sp->datablock_use[i];
               for(j=0; j<8; ++j)
               {
                       bit[j] = quotient %
2;
                       quotient = quotient
/ 2;
               }
               for(j=0; j<8; ++j)
                       if(bit[j] ==
0)
                       {
                              stop =
1;
                              break;
                       }
               if(stop == 1)
                       break;
        }

        j = 8 * i + j;
        return j;
}
void bit_inode(super *sp, int in)
{
        int i, j;

        i = in / 8;
        j = in % 8;

        sp->inode_use[i] =
(sp->inode_use[i]) ^ (1 << j);
}
void bit_data(super *sp, int dn)
{
        int i, j;

        i = dn / 8;
        j = dn % 8;

        sp->datablock_use[i] =
(sp->datablock_use[i]) ^ (1 << j);
}
int name_find(inode *ip, char words[], inode *now_d)
{
        int i, j, k, l;
        int find = 0, num;
        int stop = 0;
        char dir_name[5];
        data *tmp;

        k = now_d->db;
        tmp = dblock[k];
        while(tmp!=NULL)
        {
               for(j=0; j<24;
++j)
               {
                       if(tmp->con.dc[j][0]=='\0')
                       {
                              stop =
1;
                              break;
                       }
                       else
                       {
                              for(l=0;
(l<4)||(tmp->con.dc[j][l+3]!='\0'); ++l)
                                      dir_name[l]
= tmp->con.dc[j][l+3];
                              dir_name[l]
= '\0';
                              
                              if(strcmp(dir_name,
words)==0)
                              {
                                      find
= 1;
                                      num
= 100 * (tmp->con.dc[j][0] - 48) + 10 * (tmp->con.dc[j][1] - 48) +
(tmp->con.dc[j][2] - 48);
                                      break;
                              }

                       }
               }
               if(find == 1)
                       break;

               tmp = tmp->link;
        }

        if(find == 1)
        {
               if(strcmp(ip[num].file_type,
"directory")==0)
                       return 1;
               else
                       return 2;
        }
        else
               return 0;
}
 

